[["index.html", "A Comparison of Carnivore Monitoring Techniques Chapter 1 Project Description", " A Comparison of Carnivore Monitoring Techniques Lindsey Engelbert 2023-04-21 Chapter 1 Project Description This chapter of my dissertation will compare the precision, efficiency, and cost-effectiveness of four wildlife monitoring techniques - GPS collars, remote camera traps, hair snares, and scat detection dogs - at “capturing” and estimating density for sympatric large mammalian carnivores in Utah, specifically black bears, bobcats,and cougars. This will involve comparing the number of raw detections (i.e., the proportion of cells where a species was detected by a single survey method) and the number of unique detections (i.e., the number of times a detection by a given method represented the only detection of that species). I will compare these metrics across methods and species. It will also involve calculating the per survey cost of each method. Lastly, I will run various population models with the data to estimate the abundance and/or density of each species and compare the precision of each population estimation model and its source data. "],["designing-and-building-my-database.html", "Chapter 2 Designing and Building my Database 2.1 Database structure 2.2 Creating the database", " Chapter 2 Designing and Building my Database 2.1 Database structure Figure 2.1: Diagram illustrating the stucture of the database 2.2 Creating the database This is the code I used to create the database. I started by loading the DBI and RSQLite packages: library(DBI) library(RSQLite) Then, I both created and established a connection to a SQLite database using a single line of code. montech_db &lt;- dbConnect(RSQLite::SQLite(), &quot;montech.db&quot;) 2.2.1 Creating the carnivores table This table includes all the information about individuals that are part of my study. The table includes columns for carnivore ID, ear tag, sex, birth year, age class, and species. The carnivore_id column contains a unique identifier and, as such, it is the primary key of this table. carnivores &lt;- dbExecute(montech_db, &quot;CREATE TABLE carnivores ( carnivore_id varchar(9) NOT NULL, ear_tag integer(4), sex char(1) CHECK (sex IN (&#39;M&#39;, &#39;F&#39;)), birth_year integer(4), age_class varchar(8) CHECK (age_class IN (&#39;juvenile&#39;, &#39;subadult&#39;, &#39;adult&#39;)), species varchar(9) CHECK (species IN (&#39;cougar&#39;, &#39;blackbear&#39;, &#39;bobcat&#39;)), PRIMARY KEY (carnivore_id) );&quot;) 2.2.2 Creating the collars table This table includes all the details for each GPS collars deployed on black bears, bobcats, and mountain lions in my study area. The table includes columns for collar id, collar frequency, collar brand, collar model, and collar status. The collar_id column contains a unique identifier and is therefore the primary key for this table. collars &lt;- dbExecute(montech_db, &quot;CREATE TABLE collars ( collar_id integer(6) NOT NULL, frequency real (6), brand char(3) CHECK (brand IN (&#39;ATS&#39;)), model varchar (10), status char(11) CHECK (status IN (&#39;deployed&#39;, &#39;office&#39;)), PRIMARY KEY (collar_id) );&quot;) 2.2.3 Creating the deployments table This table includes all the information related to GPS collar deployments in my study area. The table includes columns for collar id, carnivore id, date deployed, and the date the collar stopped working or was retrieved. As there was no unique identifier for this table, I created an auto incremented deployment_id that could act as the primary key for this table. The table is related to the collars table through collar_id column and the carnivore table through the carnivore_id column. deployments &lt;- dbExecute(montech_db, &quot;CREATE TABLE deployments ( deployment_id integer PRIMARY KEY AUTOINCREMENT, collar_id integer(5), carnivore_id varchar(9), start_deployment text, end_deployment text, FOREIGN KEY(collar_id) REFERENCES collars(collar_id) FOREIGN KEY(carnivore_id) REFERENCES carnivores(carnivore_id) );&quot;) 2.2.4 Creating the raw GPS data table This table includes all the raw GPS data for collared animals in my study. The table includes columns for fix id, collar id, fix timestamp, and coordinates. As there was no unique identifier for this table, I created an auto incremented fix_id that could act as the primary key for this table. The table is related to the collars table through collar_id column. gps_data &lt;- dbExecute(montech_db, &quot;CREATE TABLE gps_data ( fix_id integer PRIMARY KEY AUTOINCREMENT, collar_id integer(5), timestamp text, utm_x double, utm_y double, FOREIGN KEY(collar_id) REFERENCES collars(collar_id) );&quot;) 2.2.5 Creating the capture sites table This table includes all capture locations of animals collared for my study. The table includes columns for the capture unit, subunit, and area. As there was no unique identifier for this table, I created an auto incremented capture_location that could act as the primary key for this table. capture_sites &lt;- dbExecute(montech_db, &quot;CREATE TABLE capture_sites ( capture_location integer PRIMARY KEY AUTOINCREMENT, capture_area varchar PRIMARY KEY, capture_subunit char CHECK (capture_subunit IN (&#39;Nebo&#39;, &#39;Manti&#39;)), capture_unit char(16) CHECK (capture_unit IN (&#39;CentralMountians&#39;)) );&quot;) 2.2.6 Creating the captures table This table includes relevant information on carnivore captures for my study. The table includes columns for the capture id, carnivore id, capture date, capture time, capture area, coordinates for the capture location, capture method, and the tissue sample id. The capture_id column contains a unique identifier and is therefore the primary key for this table. The table is related to the carnivores table through carnivore_id column and the capture sites table through the capture_area column. captures &lt;- dbExecute(montech_db, &quot;CREATE TABLE captures ( capture_id varchar PRIMARY KEY, carnivore_id varchar(9), date text, time text, capture_area varchar, utm_x float, utm_y float, capture_method varchar CHECK (capture_method IN (&#39;hounds&#39;, &#39;boxtrap&#39;, &#39;leghold&#39;)), tissue_sample_id varchar, FOREIGN KEY (carnivore_id) REFERENCES carnivores(carnivore_id) FOREIGN KEY (capture_area) REFERENCES capture_sites(capture_area) );&quot;) 2.2.7 Creating the sampling cells table This table includes information on the sampling design of my study. Each sampling cell will contain at least one hair snare, a paired camera station, and scat transects. The table includes columns for the cell id, grid id, start and end dates for the cell’s sampling period, and coordinates for the cell center. The cell_id column contains a unique identifier and is therefore the primary key for this table. sampling_cells &lt;- dbExecute(montech_db, &quot;CREATE TABLE sampling_cells ( cell_id varchar NOT NULL, grid_id integer(2), start_date text, end_date text, utm_x float, utm_y float, PRIMARY KEY (cell_id) );&quot;) 2.2.8 Creating the sampling periods table This table provides the dates for each sampling period. The sampling_periods column contains a unique identifier and is therefore the primary key for this table. sampling_periods &lt;- dbExecute(montech_db, &quot;CREATE TABLE sampling_periods ( sampling_period integer(2) PRIMARY KEY, start_date text, end_date text );&quot; 2.2.9 Creating the cameras table This table includes information on cameras deployed for my study. The table includes columns for the camera id, cell id, camera coordinates, and camera location. The camera_id column contains a unique identifier and is therefore the primary key for this table. The table is related to the sampling cells table through cell_id column. cameras &lt;- dbExecute(montech_db, &quot;CREATE TABLE cameras ( camera_id varchar NOT NULL, cell_id varchar, utm_x float, utm_y float, location varchar CHECK (location IN (&#39;dirt_road&#39;, &#39;hiking_trail&#39;, &#39;game_trail&#39;, &#39;wash&#39;, &#39;off_trail&#39;, &#39;other&#39;)), PRIMARY KEY (camera_id), FOREIGN KEY (cell_id) REFERENCES sampling_cells(cell_id) );&quot;) 2.2.10 Creating the photos table This table includes information on carnivore photos taken by camera traps. The table includes columns for the photo id, camera id, sampling period, timestamp, species, carnivore id if applicable, and individual id. The photo_id column contains a unique identifier and is therefore the primary key for this table. The table is related to the carnivores table through carnivore_id column and the capture sites table through the capture_area column. photos &lt;- dbExecute(montech_db, &quot;CREATE TABLE photos ( photo_id varchar PRIMARY KEY, camera_id varchar, sampling_period integer(2), timestamp text, species varchar(9) CHECK (species IN (&#39;cougar&#39;, &#39;blackbear&#39;, &#39;bobcat&#39;, &#39;coyote&#39;)), carnivore_id varchar(9), individual_id varchar, FOREIGN KEY (camera_id) REFERENCES cameras(camera_id) FOREIGN KEY (carnivore_id) REFERENCES carnivores(carnivore_id) FOREIGN KEY (sampling_period) REFERENCES sampling_periods(sampling_period) );&quot;) 2.2.11 Creating the transects table This table includes information on the transects walked by scat detector dogs and handlers. The table includes columns for the transect id, start and end coordinates, and the id of the track recorded by handlers. The transect_id column contains a unique identifier and is therefore the primary key for this table. transects &lt;- dbExecute(montech_db, &quot;CREATE TABLE transects ( transect_id varchar NOT NULL, start_utm_x float, start_utm_y float, end_utm_x float, end_utm_y float, track_id varchar, PRIMARY KEY (transect_id) );&quot;) 2.2.12 Creating the scat samples table This table includes information related to scat samples. The table includes columns for sample_id, date and time collected, sampling period, transect id, who collected the scat, cell age, scat coordinates, scat age, suspected species, and sample preservation method. The sample_id column contains a unique identifier and is therefore the primary key for this table. The table is related to the sampling periods table through the sampling_periods column and the transects table through the transect_id column. scat_samples &lt;- dbExecute(montech_db, &quot;CREATE TABLE scat_samples ( sample_id varchar NOT NULL, date text, time text, sampling_period integer(2), transect_id varchar, collected_by varchar, cell_id varchar, utm_x float, utm_y float, sample_age varchar CHECK (sample_age IN (&#39;fresh&#39;, &#39;medium&#39;, &#39;old&#39;)), suspected_species varchar, preservation_method char CHECK (preservation_method IN (&#39;dehydration&#39;, &#39;ethanol&#39;, &#39;shield&#39;)), PRIMARY KEY (sample_id), FOREIGN KEY (sampling_period) REFERENCES sampling_periods(sampling_period) FOREIGN KEY (transect_id) REFERENCES transects(transect_id) );&quot;) 2.2.13 Creating the hair snares table This table includes information on hair snares deployed for my study. The table includes columns device id, device type, cell id, start and end deployment dates, and snare coordinates. The device_id column contains a unique identifier and is therefore the primary key for this table. The table is related to the sampling cells table through the sampling_cells column. hair_snares &lt;- dbExecute(montech_db, &quot;CREATE TABLE hair_snares ( device_id varchar NOT NULL, device_type varchar CHECK (device_type IN (&#39;cubby&#39;, &#39;corral&#39;, &#39;pad&#39;)), cell_id varchar, start_deployment text, end_deployment text, utm_x float, utm_y float, PRIMARY KEY (device_id), FOREIGN KEY (cell_id) REFERENCES sampling_cells(cell_id) );&quot;) 2.2.14 Creating the hair samples table This table includes information related to hair samples collected for my study. The table includes columns for sample_id, date and time collected, sampling period, cell id, device_id, who collected the hair, and the scent used. The sample_id column contains a unique identifier and is therefore the primary key for this table. The table is related to the sampling cells table through the cell_id column, the sampling periods table through the sampling_periods column, and the hair snares table through the device_id column. hair_samples &lt;- dbExecute(montech_db, &quot;CREATE TABLE hair_samples ( sample_id varchar NOT NULL, date text, time text, cell_id varchar, sampling_period integer(2), device_id varchar, collected_by char, scent_used char, PRIMARY KEY (sample_id) FOREIGN KEY (cell_id) REFERENCES sampling_cells(cell_id) FOREIGN KEY (sampling_period) REFERENCES sampling_periods(sampling_period) FOREIGN KEY (device_id) REFERENCES hair_snares(device_id) );&quot;) 2.2.15 Creating the genetics table This table includes genetic information for processed hair, scat, and tissue samples collected for my study. The table includes columns for genetic id, genetic method, sample type, sample id, tissue sample id, carnivore id, carnivore species, and sex. As there was no unique identifier for this table, I created an auto incremented genetic_number that could act as the primary key for this table. The table is related to both the hair sample and scat sample tables through the sample_idcolumn, the capture table through the tissue_sample_id column, and the carnivores table through the carnivore_id column. genetics &lt;- dbExecute(montech_db, &quot;CREATE TABLE genetics ( genetic_number integer PRIMARY KEY AUTOINCREMENT, genetic_id varchar, genetic_method varchar, sample_type char CHECK (sample_type IN (&#39;hair&#39;, &#39;scat&#39;, &#39;tissue&#39;, &#39;blood&#39;)), sample_id varchar, tissue_sample_id varchar, carnivore_id varchar, species varchar(9) CHECK (species IN (&#39;cougar&#39;, &#39;blackbear&#39;, &#39;bobcat&#39;, &#39;coyote&#39;)), sex char(1) CHECK (sex IN (&#39;F&#39;, &#39;M&#39;)), FOREIGN KEY (sample_id) REFERENCES hair_samples(sample_id) FOREIGN KEY (sample_id) REFERENCES scat_samples(sample_id) FOREIGN KEY (tissue_sample_id) REFERENCES captures(tissue_sample_id) FOREIGN KEY (carnivore_id) REFERENCES carnivores(carnivore_id) );&quot;) "],["cleaning-the-raw-data.html", "Chapter 3 Cleaning the Raw Data 3.1 Preliminary steps 3.2 Formating Data for the Tables 3.3 Adding Data to the Database", " Chapter 3 Cleaning the Raw Data Now that the database is built, the raw cougar and black bear data that I’m getting from Utah’s Wildlife Tracker needs to be transformed into a format that can be imported into my monitoring techniques database. The data from Wildlife Tracker will go into my carnivore, capture_sites, collar, deployments, and gps_data tables. 3.1 Preliminary steps 3.1.1 Load Libraries Load all the libraries I’ll need to run the code library(DBI) library(RSQLite) library(tidyverse) library(lubridate) library(sf) 3.1.2 Database connection Then make sure that there’s still a connection with the monitoring techniques database. montech_db &lt;- dbConnect(RSQLite::SQLite(), &quot;montech.db&quot;) 3.1.3 Import the raw data Import the raw data from wildlife tracker raw_data &lt;- read.csv(&quot;raw_data/2023-04-11_GPS_Data.csv&quot;, header = TRUE) Once these preliminary steps are completed, we can actually clean the data. 3.2 Formating Data for the Tables 3.2.1 Carnivore table formating I’ll start with the data needed for the carnivores table. I’ll need to pull the columns uniqueID, earTag, sex, birthYear, currentCohort, and species from the raw data using the select() function. Since these columns have different names than the names of my fields in my database table I then need to rename each column using the rename() function. Then, because there are many entries for each carnivore_id, I need to pull only the unique carnivore ids. In this case I used filter(!duplicated(carnivore_id)) instead of distinct because Wildlife Tracker calculates the age class based on the birth year so there were duplicate rows for individuals that were unique because the collar had been on them for multiple age classes. Finally, I need to make sure that my entries matched the table constraints. This meant deleting all the spaces in the entries using the gsub() function. carnivores &lt;- raw_data %&gt;% select(uniqueID, earTag, sex, birthYear, currentCohort, species) %&gt;% rename(carnivore_id = uniqueID, ear_tag = earTag, birth_year = birthYear, age_class = currentCohort) %&gt;% arrange(age_class) %&gt;% filter(!duplicated(carnivore_id)) %&gt;% mutate(species = gsub(&quot; &quot;, &quot;&quot;, species)) 3.2.2 Collar table formating I’ll next create the collars table. Again, I’ll need to pull only the necessary columns using the select() function. In this case, it’s only collarID and freq. Since Wildlife Tracker doesn’t contain information on brand, model, or status I had to create placeholder columns populated with NAs until I can acquire that data from a different source. This time the columns are in a different order than what I need for my database, so I used the relocate()function to reorder them. I then renamed the necessary columns and finally pulled out the unique entries using the distinct() function. collars &lt;- raw_data %&gt;% select(collarID, freq) %&gt;% mutate(brand = NA, model = NA, status = NA) %&gt;% relocate(freq, .after = status) %&gt;% rename(collar_id = collarID, frequency = freq) %&gt;% distinct() 3.2.3 Deployments table formating For the deployments table, I needed to pull carnivoreID and collarID from the raw Wildlife Tracker data. Since I don’t yet have data on the deployment start and end dates, I just created empty columns for those fields and populated them with NA until I acquire the necessary data. Finally, I reordered the columns according to my database format using relocate()and grabbed only the unique combinations of columns using disctinct(). deployments &lt;- raw_data %&gt;% select(uniqueID, collarID) %&gt;% rename(carnivore_id = uniqueID, collar_id = collarID) %&gt;% relocate(collar_id, .before = carnivore_id) %&gt;% mutate(start_deployment = NA, end_deployment = NA) %&gt;% distinct() 3.2.4 Capture sites table formating For the capture sites table, I needed to pull the captureUnit, captureSubUnit, and realCaptureArea columns from the Wildlife Tracker data using select(). I then renamed them and switched the order of the columns so that it matched my database table. As there were multiple columns with spaces in the entries, I had to eliminate those using gsub so that it matched the database table constraints. Lastly, I took only the unique combinations of entries by using distinct(). capture_sites &lt;- raw_data %&gt;% select(captureUnit, captureSubUnit, realCaptureArea) %&gt;% rename(capture_unit = captureUnit, capture_subunit = captureSubUnit, capture_area = realCaptureArea) %&gt;% relocate(capture_area, .before = capture_unit) %&gt;% relocate(capture_subunit, .after = capture_area) %&gt;% mutate(capture_area = gsub(&quot; &quot;, &quot;&quot;, capture_area)) %&gt;% mutate(capture_unit = gsub(&quot; &quot;, &quot;&quot;, capture_unit)) %&gt;% distinct() 3.2.5 GPS data table formating Yet again, I pulled the columns that I wanted from the raw Wildlife Tracker data and renamed and ordered them appropriately. This included collarID, datYearAndJUlian, litutde, and longitude. I then had to tell R that the timestamp column is a time and date, as well as the format and timezone of that time and date. gps_data &lt;- raw_data %&gt;% select(collarID, dateYearAndJulian, latitude, longitude) %&gt;% rename(collar_id = collarID, timestamp = dateYearAndJulian) %&gt;% relocate(longitude, .before = latitude) %&gt;% mutate(timestamp = mdy_hm(timestamp, tz = &quot;America/Denver&quot;)) There were then a number of steps I had to take to convert the fix points from lat long to utm. First, I had to turn the lat long columns into a spatial object so that R could recognize them as such. Then I could transform that spatial object to utm coordinates and pull just those columns from the data. I then joined those utm easting and northing columns back with the object I created from the Wildlife Tracker data, deleted the lat long columns, and renamed the utm columns so that they matched my database table. utm_coords &lt;- gps_data %&gt;% st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) %&gt;% st_transform(crs = 32612) %&gt;% st_coordinates() gps_data &lt;- cbind(gps_data, utm_coords) %&gt;% select(collar_id, timestamp, X, Y) %&gt;% rename(utm_x = X, utm_y = Y) 3.3 Adding Data to the Database Now that the data is cleaned and organized according to the format of the monitoring techniques database tables, we can actually add the data to the tables. This is a simple process that can be done with a single line of code for each table. Since this is our first time adding we can merely tell it to append the data to the table. However, in the future when we have to be careful about whether we’re telling it to append or overwrite the data. In cases where we’re downloading all the data that exists for a table we can tell it to overwrite, but in cases where we’re merely adding data that’s new since the last time we downloaded we need to make sure we’re telling it to append that data to what already exists in the table. 3.3.1 Carnivore table Here I added the data I pulled and formatted from the Wildlife Tracker raw data to the carnivores table in the montech.db. dbWriteTable(montech_db, &quot;carnivores&quot;, carnivores, append = TRUE) 3.3.2 Collars table Here I added the data I pulled and formatted from the Wildlife Tracker raw data to the collars table in the montech.db. dbWriteTable(montech_db, &quot;collars&quot;, collars, append = TRUE) 3.3.3 Deployments table Here I added the data I pulled and formatted from the Wildlife Tracker raw data to the deployments table in the montech.db. dbWriteTable(montech_db, &quot;deployments&quot;, deployments, append = TRUE) 3.3.4 Capture sites table Here I added the data I pulled and formatted from the Wildlife Tracker raw data to the capture sites table in the montech.db. dbWriteTable(montech_db, &quot;capture_sites&quot;, capture_sites, append = TRUE) 3.3.5 GPS data table Here I added the data I pulled and formatted from the Wildlife Tracker raw data to the gps data table in the montech.db. dbWriteTable(montech_db, &quot;gps_data&quot;, gps_data, append = TRUE) "],["visualizing-the-data.html", "Chapter 4 Visualizing the data", " Chapter 4 Visualizing the data Now that we have some data in our database, let’s take a look at what we have. Since we don’t have much data, let’s just examine the data from the carnivores table such as how many of each species we have collared and what the age class and sex ratios are for each species. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
